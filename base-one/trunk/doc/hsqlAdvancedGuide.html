<html>
<head>
<meta http-equiv="Content-Type" content="text/html>
</head>
<body link="#0000ff" vlink="#800080">

<h2>ADVANCED TOPICS</h2>
<h3>PROPERTIES FILES</h3>
<p>HSQLDB relies on a set of properties files for different settings. Version 1.7.0 streamlines the property naming and introduces a number of new properties. This process will continue with future versions and the properties will be used in a hierarchical manner. The properties files and the settings stored in them are as follows:</p>
<p><code>server.properties</code> - settings for running HSQLDB as a database server communicating with the HSQL protocol</p>
<p><code>webserver.properties</code> - settings for running HSQLDB as a database server communicating with the HTTP protocol</p>
<p><code>&lt;dbname&gt;.properties</code> - settings for each particular database</p>
<p>In all properties files, values are case-sensitive. All values apart from names of files or pages are required in lowercase (e.g.<code> server.silent=FALSE</code> will have no effect, but <code>server.silent=false </code>will work).</p>
<p>&nbsp;In server.properties and webserver.properties files, supported values and their defaults are as follows:</p>
<table border cellspacing=1 cellpadding=9 width=798>
   <tr>
      <td width="33%" valign="TOP">
         <p>VALUE
      </td>
      <td width="33%" valign="TOP">
         <p>DEFAULT
      </td>
      <td width="33%" valign="TOP">
         <p>DESCRIPTION
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.database </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>test </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>the path and file name of the database file to use
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.silent </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>true </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>no extensive messages displayed on console
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.trace </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>false </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>JDBC trace messages displayed on console
      </td>
   </tr>
</table>

<p>&nbsp;</p>
<p>Values specific to server.properties are:</p>
<table border cellspacing=1 cellpadding=9 width=798>
   <tr>
      <td width="33%" valign="TOP">
         <p>VALUE
      </td>
      <td width="33%" valign="TOP">
         <p>DEFAULT
      </td>
      <td width="33%" valign="TOP">
         <p>DESCRIPTION
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.port </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>9001</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>TCP/IP port used for talking to clients
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.no_system_exit </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>false</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>no System.exit() call when the database is closed
      </td>
   </tr>
</table>

<p>&nbsp;</p>
<p>Values specific to webserver.properties are:</p>
<table border cellspacing=1 cellpadding=9 width=798>
   <tr>
      <td width="33%" valign="TOP">
         <p>VALUE
      </td>
      <td width="33%" valign="TOP">
         <p>DEFAULT
      </td>
      <td width="33%" valign="TOP">
         <p>DESCRIPTION
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.port </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>80 </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>TCP/IP port used for talking to clients
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.default_page </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>index.html </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>the default page for server
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>server.root </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>./ </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>the location of served pages
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>.&lt;extension&gt; </pre>
      </td>
            
      <td width="33%" valign="TOP">
         <pre>? </pre>
      </td>
      <td width="33%" valign="TOP">
         <p>multiple entries such as .html=text/html define the mime types of the static files served by the web server. See the source for WebServer.java for a list.
      </td>
   </tr>
</table>

<p>&nbsp;</p>
<p>All the above values can be specified on the command line by omitting the server. prefix.</p>
<p><i>Upgrading: If you have existing custom properties files, change the values to the new naming convention.</i></p>
<h4>Individual Database Properties</h4>
<p>Each database has its own <code>&lt;dbname&gt;.properties</code> file as part of a small group of files which also includes <code>&lt;dbname&gt;.script </code>and <code>&lt;dbname&gt;.data</code> . The properties files contain key/value pairs for some important settings. Only the user-defined values listed below should ever be modified. Changing any other value will result in unexpected malfunction in database operations.</p>
<p>User-defined values that have been introduced for the new features are listed below with their default values in different contexts:</p>
<table border cellspacing=1 cellpadding=9 width=798>
   <tr>
      <td width="33%" valign="TOP">
         <p>VALUE
      </td>
      <td width="33%" valign="TOP">
         <p>DEFAULT
      </td>
      <td width="33%" valign="TOP">
         <p>DESCRIPTION
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>jdbc.get_column_name </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>true</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>column name in ResultSet
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>When true, returns the underlying column name with ResultSet.getColumnName(int c)</p>
         <p>When false, returns the value for ResultSet.getColumnLabel(int c)
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>sql.month</pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>true</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>month(Date) return value
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>When true, returns month 1-12 instead of 0-11 with the Library function, month(java.sql.Date d)</p>
         <p>When false, returns 0-11 as it did before 1.7.0
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>sql.enforce_size </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>false</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>trimming and padding string columns 
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>When true, all CHARACTER and VARCHAR values that are in a row affected by an INSERT INTO or UPDATE statement are trimmed to the size specified in the SQL table definition. Also all char strings that are shorter than the specified size are padded with spaces. When false (default), stores the exact string that is inserted. 
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>sql.compare_in_locale </pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>false</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>locale used for sorting
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>CHARACTER and VARCHAR columns are by default sorted according to POSIX standards. Setting the value to true will result in sorting in the character set of the current JRE locale.</p>
         <p>Changing this value for an existing database that contains cached tables will break the indexing and result in inconsistent operation. To avoid this, first change the value in the properties file, then open the database and issue the SHUTDOWN COMPACT command to recreate all the indexes.
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>sql.strict_fk</pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>true (false for existing db's)</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>require unique index for foreign keys
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>The default is false when opening a database created with an older version of HSQLDB; true when creating a new database.</p>
         <p>If true, requires a pre-existing unique index for the column(s) referenced by a foreign key constraint and returns an error if the index does not already exist.</p>
         <p>If false, creates an index if no index exists, based on the<code> sql.strong_fk </code>property below.</p>
         <p>Changing this value to true on an existing database may result in errors when the database is opened.
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>sql.strong_fk</pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>true</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>make unique index for foreign keys
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>Has no effect if <code>sql.strict_fk</code> is true. By default, when 1.7.0 opens a database created by previous version of the program, it creates a unique index for referenced column of the foreign key instead of a non-unique index created by previous versions of HSQLDB. This is done if there isn't already a primary key or unique constraint on the referenced column(s).</p>
         <p>If you have an existing database which relies on an automatic index (there is no primary key or unique constraint on the referenced columns) and has duplicate values in the columns, then 1.7.0 will report an exception when you attempt to open the database. If this happens, you can manually add a line to the .properties file with:</p>
         <p><code>sql.strong_fk=false</code></p>
         <p>in order to allow the old database to be opened. It is a good idea to modify the data and remove the duplicate values, as these would cause data integrity problems. You can then change the value to true for future operations.
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>hsqldb.cache_scale</pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>15</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>memory cache exponent
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>Indicates the size of memory cache used with cached tables, calculated as 2^value. The default results in just over 32000 rows from all cached tables being held in memory at any time. </p>
         <p>The value can range between 8-16.
      </td>
   </tr>
   <tr>
      <td width="33%" valign="TOP">
         <pre>hsqldb.gc_interval</pre>
      </td>
      <td width="33%" valign="TOP">
         <pre>0</pre>
      </td>
      <td width="33%" valign="TOP">
         <p>forced garbage collection
      </td>
   </tr>
   <tr>
      <td valign="TOP" colspan=3>
         <p>This setting forces garbage collection each time a set number of result set row or cache row objects are created. The default, "0" means no garbage collection is forced by the program.</p>
         <p>This should not be set when the database engine is acting as a server. The setting can be useful, when the database is used in-process with some Java Runtime Environments (JRE’s). Some JRE’s increase the size of the memory heap before doing any automatic garbage collection. This setting would prevent any unnecessary enlargement of the heap. Typical values for this setting would probably be between 10,000 to 100,000.
      </td>
   </tr>
</table>

<p>&nbsp;</p>
<p><i>Upgrading: The location of the database files can no longer be overridden by paths defined in the properties file. All files belonging to a database should reside in the same directory.</i></p>
<h3>CONSTRAINTS AND INDEXES</h3>
<p>Version 1.7.0 features major improvements on previous versions in this area. Previously a CONSTRAINT &lt;name&gt; PRIMARY KEY was translated internally to a unique index and, in addition, a hidden column was added to the table with an extra unique index. In 1.7.0 both single-column and multi-column PRIMARY KEY constraints are supported. They are supported by a unique index on the primary key column(s) specified and no extra hidden column is added.</p>
<p>CONSTRAINT UNIQUE always creates a unique index on the columns, as with previous versions.</p>
<p>Note that in HSQLDB a unique index on multiple columns is used internally as a non-unique index on the first columns in the list. For example: <code>CREATE UNIQUE INDEX name1 ON atable(c1, c2, c3);</code> means there is the equivalent of <code>CREATE INDEX name2 ON atable(c1);</code> So you do not need to specify an extra index if you require one on the first column of the list.</p>
<p>A multi-column index will not speed up queries that contain joins on any column other than the first. You should declare individual indexes (or unique constraints) on those columns if they appear in joins or query conditions.</p>
<p>In multiple key indexes, the order of declared columns can affect the speed of searches. If the column that contains more diverse values appears first, the searches will be faster.</p>
<h4>FOREIGN KEYS</h4>
<p>Version 1.7.0 features single and multiple column foreign keys. A foreign key can also be specified to reference a target table without naming the target column(s). In this case the primary key column(s) of the target table is used as the referenced column(s). Each pair of referencing and referenced columns in any foreign key should be of identical type. In the default mode, when a foreign key is declared, a unique index (or primary key index) must exist on the referenced columns in the primary key table. A non-unique index is automatically created on the referencing columns. For example:</p>
<pre>CREATE TABLE child(c1 INTEGER, c2 VARCHAR, FOREIGN KEY (c1, c2) REFERENCES parent(p1, p2));</pre>
<p>There must be a unique CONSTRAINT or INDEX on columns<code> (p1,p2)</code> in the table named "parent". A non-unique index is automatically created on columns <code>(c1, c2)</code> in the table named "child". Columns <code>p1</code> and <code>c1</code> must be of the same type (INTEGER). Columns<code> p2</code> and <code>c2</code> must be of the same type (VARCHAR).</p>
<h3>TYPES ARITHMETIC OPERATIONS</h3>
<p>Table columns of all types supported by HSQLDB can be indexed and can feature in comparisons. Types can be explicitly converted using the CONVERT() library function, but in most cases they are converted automatically.</p>
<p>Previous versions of HSQLDB featured poor handling of arithmetic operations. For example, it was not possible to insert 10/2.5 into any DOUBLE or DECIMAL column. In 1.7.0, full operations are possible with the following rules:</p>
<p>TINYINT, SMALLINT, INTEGER, BIGINT, NUMBER and DECIMAL (without a decimal point) are supported integral types and map to byte, short, int, long and BigDecimal in Java. The SQL type dictates the maximum and minimum values that can be held in a field of each type. For example the value range for SMALLINT is –128 to +127, although the actual Java type used for handling SMALLINT is java.lang.Integer.</p>
<p>REAL, FLOAT, DOUBLE are all mapped to double in Java.</p>
<p>DECIMAL and NUMERIC are mapped to java.math.BigDecimal and can have very large numbers of digits before or after the decimal point.</p>
<h4>INTEGRAL TYPES</h4>
<p>TINYINT, SMALLINT, INTEGER, BIGINT, NUMBER and DECIMAL (without a decimal point) are fully interchangeable internally, and no data narrowing takes place. Depending on the types of the operands, the result of the operations is returned in a JDBC ResultSet in any of related Java types: Integer, Long or BigDecimal. The ResultSet getXXXX methods can be used to retrieve the value work so long as the returned value can be represented by the resulting type.</p>
<p>If the SELECT statement refers to a simple column or function, then the return type is the type corresponding to the column or the return type of the function. For example:</p>
<pre>CREATE TABLE t(a INTEGER, b BIGINT);</pre>
<pre>SLEECT a, MAX(b) FROM t;</pre>
<p>Would return a result set where the type of the first column is java.lang.Integer and the second column is java.lang.Long. However,</p>
<pre>SELECT a + 0, MAX(b) + 0 FROM t;</pre>
<p>would return <code>java.lang.Long</code> and <code>BigDecimal</code> values, generated as a result of uniform type promotion for all the return values.</p>
<p>There is no built-in limit on the size of intermediate integral values in expressions. As a result, you should check for the type of the ResultSet column and choose an appropriate <code>getXXXX()</code> method to retrieve it. Alternatively, you can use the <code>getObject() </code>method, then cast the result to <code>java.lang.Number</code> and use the<code> intValue()</code> or <code>longValue()</code> methods on the result.</p>
<p>When the result of an expression is stored in a column of a database table, it has to fit in the target column, otherwise an error is returned. For example when <code>1234567890123456789012 / 12345687901234567890</code> is evaluated, the result can be stored in any integral type column, even a SMALLINT column, as it is a small value.</p>
<h4>OTHER NUMERIC TYPES</h4>
<p>In SQL statements, numbers with a decimal point are treated as DECIMAL unless they are written with an exponent. Thus 0.2 is considered a DECIMAL value but 0.2E0 is considered a DOUBLE value.</p>
<p>When <code>PreparedStatement.setDouble()</code> or <code>setFloat()</code> is used, the value is treated as a DOUBLE automatically. </p>
<p>When a REAL, FLOAT or DOUBLE (all synonymous) is part of an expression, the type of the result is DOUBLE. </p>
<p>Otherwise, when no DOUBLE value exists, if a DECIMAL or NUMBER value is part an expression, the type of the result is DECIMAL. The result can be retrieved from a ResultSet in the required type so long as it can be represented. This means DECIMAL values can be converted to DOUBLE unless they are beyond the Double.MIN_VALUE-Double.MAX_VALUE range. Similar to integral values, when the result of an expression is stored in a table column, it has to fit in the target column, otherwise an error is returned.</p>
<p>The distinction between DOUBLE and DECIMAL is important when a division takes place. When the terms are DECIMAL, the result is a value with a scale (number of digits to the right of the decimal pint) equal to the larger of the scales of the two terms. With a DOUBLE term, the scale will reflect the actual result of the operation. For example, 10.0/8.0 (DECIMAL) equals 1.2 but 10.0E0/8.0E0 (DOUBLE) equals 1.25. Without division operations, DECIMAL values represent exact arithmetic and the resulting scale is the sum of the scales of the two terms when multiplication is performed.</p>
<h4>BIT TYPE</h4>
<p>BIT columns in HSQLDB are in fact boolean columns. BIT columns can be initialised using values of any numeric type. In this case 0 is translated to <code>"false"</code> and any other value is translated to <code>"true"</code>. Note that the primary representation of BIT column is <code>"true"</code> or <code>"false"</code> either as strings or as the boolean type when used from JDBC.</p>
<h4>IDENTITY TYPE</h4>
<p>Support has been added for <code>CREATE TABLE &lt;tablename&gt;(&lt;colname&gt; IDENTITY, ...)</code> to allow IDENTITY used on it's own as a type. This is translated internally to <code>(&lt;colname&gt; INTEGER IDENTITY, ...)</code> which is the default syntax. When you create a new row in such a table using an <code>INSERT INTO &lt;tablename&gt; ...; </code> statement, you can use the NULL value for the IDENTITY column, which results in an auto-generated value for the column. You can use the <code>CALL IDENTITY();</code> statement next to retrieve the value inserted into the IDENTITY column.</p>
<h4>HANDLING OF JAVA OBJECTS</h4>
<p>In version 1.7.0 any JAVA Object can be inserted directly into an OTHER column using any variation of PreparedStatement.setObject() methods or its appropriate <code>setXXX()</code> method. The exception is with String Objects: setString() will not act as expected and the <code>setObject(Object object, int type)</code> should be explicitly called to insert a String into an OTHER column.</p>
<p>This is because when the execute methods of PreparedStatement are called, everything is passed to the database as an SQL query string. As a result, the system needs to distinguish between a user supplied String and a String generated by PreparedStatement. The string generated by PreparedStatement for an Object consists of hex digits only, with each pair of digits representing a byte of a byte array formed by calling the serialize() method of the object. The internal HSQLDB method, <code>org.hsqldb.ByteArray.serializeToString(Object o)</code> performs the conversion.</p>
<p>For comparison purposes and in indexes, any two Java Objects are considered equal unless one of them is NULL.</p>
<h4>JDBC STREAM BASED METHODS</h4>
<p>The ResultSet interface methods, <code>getAsciiStream()</code>, <code>getUnicodeStream()</code> and <code>getCharacterStream()</code> are now supported to return byte or char values from CHARACTER columns and its variants. Complementary methods in PreparedStatement, <code>setAsciiStream()</code>,  <code>setUnicodeStream()</code> and <code>setCharacterStream()</code> are also supported. Unlike most other databases, the <code>getString()</code> methods can be used to retrieve very long character strings and is faster than the stream based methods. </p>
<p>Upgrading: Several JDBC methods that previously returned incorrect values now throw an SQLException. All these changes have been documented in the Javadoc for the jdbcXXX classes.</p>
<h3>MEMORY AND DISK USE</h3>
<p>Memory used by the program can be thought of as two distinct pools: memory used for table data, and memory used for building result sets. In addition, when transactions are used, memory is utilised for storing the information needed for a rollback.</p>
<p>The memory used for a table is the sum of memory used by each row. Each table row is a Java object that has 10 slots for int or reference variables. It contains an array of objects for the fields in the row. Each field is an object such as Integer, Long, String, etc. In addition each index on the table adds a node object to the row. Each node object has 12 slots for int or reference variables. As a result, a table with just one column of type INTEGER will have four objects per row, with a total of 24 slots of 4 bytes each - well over 100 bytes per row. Beyond this, each extra column in the table adds at least a few bytes to the size of each row.</p>
<p>The memory used for a result set row has fewer overheads (fewer slots and no index nodes) but still uses a lot of memory. The result set memory is released once the database server has returned the result set; in the case of in-process databases, it is released when the application program releases the java.sql.ResultSet object.</p>
<p>With cached tables, only up to a maximum number of rows are held in memory at any time. The default is 32000 rows. The hsqldb.cache_scale property can be set to alter this amount. </p>
<h3>ISSUES WITH TRANSACTIONS</h3>
<p>HSQLDB supports transactions at the READ_UNCOMMITTED level, also known as level 0 transaction isolation. This means that during the lifetime of a transaction, other connections to the database can see the changes made to the data. Transaction support works well in general. Reported bugs concerning transactions being committed if the database is abruptly closed have been fixed. However, the following issues may be encountered only with multiple connections to a database using transactions:</p>
<p>When an ALTER TABLE .. INSERT COLUMN or DROP COLUMN command results in changes to the table structure, the current session is committed. If an uncommitted transaction started by another connections has changed the data in the affected table, it may not be possible to roll it back after the ALTER TABLE command. This may also apply to ADD INDEX or ADD CONSTRAINT commands. It is recommended to use these ALTER commands only when it is known that other connections are not using transactions.</p>
<p>After a CHECKPOINT command is issued, uncommitted transactions can be continued, committed, or rolled back. However, if the database is not subsequently closed properly with the SHUTDOWN command, any such transaction that still remains uncommitted, is committed at the next startup. It is recommended not to use the CHECKPOINT command when there are any uncommitted transactions.</p>
<h3>UPGRADING DATABASES</h3>
<p>Database created with Hypersonic version 1.43 and HSQLDB 1.6x can be seamlessly upgraded to the new version. However, there may be cases where due to data inconsistencies, the upgrade may not be so simple. The following procedure is suggested for making the upgrade in the safest possible way.</p>
<ol>
   <li> Make a backup of your database.</li>
   <li> Open the database using the old version of the Database Manager software. Use the SHUTDOWN COMPACT command.</li>
   <li> Open with the old version Database Manager again and check the data  is consistent, then close it.</li>
   <li> Open the database with the new version 1.7.0 of Database Manager. Check the data is consistent.</li>
   <li> Issue the SHUTDOWN COMPACT command.</li>
   <li>Start using the database.</li>
</ol>
<p>Once a database is upgraded, it can no longer be used with Hypersonic or HSQLDB 1.6x.</p>
<p>The new ALTER commands allow you to improve and streamline the design of your database after a successful import.</p>
<h4>Some Potential Problems </h4>
<p>Version 1.7.0 does not accept duplicate names for indexes.<br>
   Version 1.7.0 does not accept duplicate names for table columns.
<br>
   Version 1.7.0 does not create the same type of index for foreign keys as previous verisons.
</p>
<p>These problems can be resolved only by editing the old database script slightly to conform to the new restrictions. So long as you just rename  index or column names, you can perform this action on the <code>.script</code>  file of the old database between stages 2 and 3 above in the upgrede process. Use a programming editor that is capable of handling very larg files.</p>
<h4>The SCRIPT command</h4>
<p>In all versions of HSQLDB and Hypersonic 1.43, the <code>SCRIPT 'filename'</code> command  (used as an SQL query) allows you to save a full record of your database, including database object definitions and data to a file of your choice. If you encounter any problems upgrading your database with the normal method, you can export a script file using the old version of the database engine and import it into an empty new database created with 1.7.0. The only potential issue involved with this is with non-ASCII characters in strings. Please let us know if you encounter any problems. We will be releasing  updated versions of DatabaseManager and Transfer Tool in the near future to  facilitate moving data between  old and new databases.</p>
<p>&nbsp;</p>
<p>Author: Fred Toussi - 14 July 2002</p>
<p>Copyright 2002 Fred Toussi. Permission is granted to distribute this document without any alteration under the terms of the HSQLDB license. Additional permission is granted to the HSQLDB Development Group to distribute this document with or without alterations under the terms of the HSQLDB license.</p>
<p><a href="http://hsqldb.sourceforge.net">http://hsqldb.sourceforge.net&nbsp;</a></p>
</body>
</html>
